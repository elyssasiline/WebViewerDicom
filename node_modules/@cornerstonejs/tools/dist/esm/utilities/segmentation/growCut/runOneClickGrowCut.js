import { vec3 } from 'gl-matrix';
import { utilities as csUtils, cache, volumeLoader } from '@cornerstonejs/core';
import { run } from './runGrowCut';
const { transformWorldToIndex, transformIndexToWorld } = csUtils;
const POSITIVE_SEED_VALUE = 254;
const NEGATIVE_SEED_VALUE = 255;
const POSITIVE_SEED_VARIANCE = 0.1;
const NEGATIVE_SEED_VARIANCE = 0.8;
const SUBVOLUME_PADDING_PERCENTAGE = 0.2;
const SUBVOLUME_MIN_PADDING = 5;
function _createSubVolume(referencedVolume, positiveRegionData, options) {
    const { dimensions } = referencedVolume;
    const positiveRegionSize = vec3.sub(vec3.create(), positiveRegionData.boundingBox.bottomRight, positiveRegionData.boundingBox.topLeft);
    let subVolumePaddingPercentage = options?.subVolumePaddingPercentage ?? SUBVOLUME_PADDING_PERCENTAGE;
    let subVolumeMinPadding = options?.subVolumeMinPadding ?? SUBVOLUME_MIN_PADDING;
    if (typeof subVolumePaddingPercentage === 'number') {
        subVolumePaddingPercentage = [
            subVolumePaddingPercentage,
            subVolumePaddingPercentage,
            subVolumePaddingPercentage,
        ];
    }
    if (typeof subVolumeMinPadding === 'number') {
        subVolumeMinPadding = [
            subVolumeMinPadding,
            subVolumeMinPadding,
            subVolumeMinPadding,
        ];
    }
    const padding = vec3.mul(vec3.create(), positiveRegionSize, subVolumePaddingPercentage);
    vec3.round(padding, padding);
    vec3.max(padding, padding, subVolumeMinPadding);
    const subVolumeSize = vec3.scaleAndAdd(vec3.create(), positiveRegionSize, padding, 2);
    const ijkTopLeft = vec3.sub(vec3.create(), positiveRegionData.boundingBox.topLeft, padding);
    const ijkBottomRight = vec3.add(vec3.create(), ijkTopLeft, subVolumeSize);
    vec3.max(ijkTopLeft, ijkTopLeft, [0, 0, 0]);
    vec3.min(ijkTopLeft, ijkTopLeft, dimensions);
    vec3.max(ijkBottomRight, ijkBottomRight, [0, 0, 0]);
    vec3.min(ijkBottomRight, ijkBottomRight, dimensions);
    const subVolumeBoundsIJK = {
        minX: ijkTopLeft[0],
        maxX: ijkBottomRight[0],
        minY: ijkTopLeft[1],
        maxY: ijkBottomRight[1],
        minZ: ijkTopLeft[2],
        maxZ: ijkBottomRight[2],
    };
    return csUtils.createSubVolume(referencedVolume.volumeId, subVolumeBoundsIJK, {
        targetBuffer: {
            type: 'Float32Array',
        },
    });
}
function _getPositiveRegionData(referencedVolume, worldPosition, options) {
    const [width, height, numSlices] = referencedVolume.dimensions;
    const subVolPixelData = referencedVolume.voxelManager.getCompleteScalarDataArray();
    const numPixelsPerSlice = width * height;
    const ijkStartPosition = transformWorldToIndex(referencedVolume.imageData, worldPosition);
    const referencePixelValue = subVolPixelData[ijkStartPosition[2] * numPixelsPerSlice +
        ijkStartPosition[1] * width +
        ijkStartPosition[0]];
    const positiveSeedVariance = options.positiveSeedVariance ?? POSITIVE_SEED_VARIANCE;
    const positiveSeedVarianceValue = Math.abs(referencePixelValue * positiveSeedVariance);
    const minPositivePixelValue = referencePixelValue - positiveSeedVarianceValue;
    const maxPositivePixelValue = referencePixelValue + positiveSeedVarianceValue;
    const neighborsCoordDelta = [
        [-1, 0, 0],
        [1, 0, 0],
        [0, -1, 0],
        [0, 1, 0],
        [0, 0, -1],
        [0, 0, 1],
    ];
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    const startVoxelIndex = ijkStartPosition[2] * numPixelsPerSlice +
        ijkStartPosition[1] * width +
        ijkStartPosition[0];
    const voxelIndexesSet = new Set([startVoxelIndex]);
    const worldVoxelSet = new Set([worldPosition]);
    const queue = [ijkStartPosition];
    while (queue.length) {
        const ijkVoxel = queue.shift();
        const [x, y, z] = ijkVoxel;
        minX = ijkVoxel[0] < minX ? ijkVoxel[0] : minX;
        minY = ijkVoxel[1] < minY ? ijkVoxel[1] : minY;
        minZ = ijkVoxel[2] < minZ ? ijkVoxel[2] : minZ;
        maxX = ijkVoxel[0] > maxX ? ijkVoxel[0] : maxX;
        maxY = ijkVoxel[1] > maxY ? ijkVoxel[1] : maxY;
        maxZ = ijkVoxel[2] > maxZ ? ijkVoxel[2] : maxZ;
        for (let i = 0, len = neighborsCoordDelta.length; i < len; i++) {
            const neighborCoordDelta = neighborsCoordDelta[i];
            const nx = x + neighborCoordDelta[0];
            const ny = y + neighborCoordDelta[1];
            const nz = z + neighborCoordDelta[2];
            if (nx < 0 ||
                nx >= width ||
                ny < 0 ||
                ny >= height ||
                nz < 0 ||
                nz >= numSlices) {
                continue;
            }
            const neighborVoxelIndex = nz * numPixelsPerSlice + ny * width + nx;
            const neighborPixelValue = subVolPixelData[neighborVoxelIndex];
            if (voxelIndexesSet.has(neighborVoxelIndex) ||
                neighborPixelValue < minPositivePixelValue ||
                neighborPixelValue > maxPositivePixelValue) {
                continue;
            }
            const ijkVoxel = [nx, ny, nz];
            const worldVoxel = transformIndexToWorld(referencedVolume.imageData, ijkVoxel);
            voxelIndexesSet.add(neighborVoxelIndex);
            worldVoxelSet.add(worldVoxel);
            queue.push(ijkVoxel);
        }
    }
    return {
        worldVoxels: Array.from(worldVoxelSet),
        boundingBox: {
            topLeft: [minX, minY, minZ],
            bottomRight: [maxX, maxY, maxZ],
        },
    };
}
function _setPositiveSeedValues(labelmap, positiveRegionData, options) {
    const { dimensions } = labelmap;
    const [width, height] = dimensions;
    const numPixelsPerSlice = width * height;
    const positiveSeedValue = options.positiveSeedValue ?? POSITIVE_SEED_VALUE;
    const { worldVoxels } = positiveRegionData;
    for (let i = 0, len = worldVoxels.length; i < len; i++) {
        const worldVoxel = worldVoxels[i];
        const ijkVoxel = transformWorldToIndex(labelmap.imageData, worldVoxel);
        const voxelIndex = ijkVoxel[2] * numPixelsPerSlice + ijkVoxel[1] * width + ijkVoxel[0];
        labelmap.voxelManager.setAtIndex(voxelIndex, positiveSeedValue);
    }
}
function _setNegativeSeedValues(subVolume, labelmap, worldPosition, options) {
    const [width, height] = subVolume.dimensions;
    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();
    const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();
    const ijkPosition = transformWorldToIndex(subVolume.imageData, worldPosition);
    const referencePixelValue = subVolPixelData[ijkPosition[2] * width * height + ijkPosition[1] * width + ijkPosition[0]];
    const negativeSeedVariance = options.negativeSeedVariance ?? NEGATIVE_SEED_VARIANCE;
    const negativeSeedValue = options.negativeSeedValue ?? NEGATIVE_SEED_VALUE;
    const negativeSeedVarianceValue = Math.abs(referencePixelValue * negativeSeedVariance);
    const minNegativePixelValue = referencePixelValue - negativeSeedVarianceValue;
    const maxNegativePixelValue = referencePixelValue + negativeSeedVarianceValue;
    for (let i = 0, len = subVolPixelData.length; i < len; i++) {
        const pixelValue = subVolPixelData[i];
        if (!labelmapData[i] &&
            (pixelValue < minNegativePixelValue || pixelValue > maxNegativePixelValue)) {
            labelmap.voxelManager.setAtIndex(i, negativeSeedValue);
        }
    }
}
async function _createAndCacheSegmentation(subVolume, positiveRegionData, worldPosition, options) {
    const labelmap = volumeLoader.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);
    _setPositiveSeedValues(labelmap, positiveRegionData, options);
    _setNegativeSeedValues(subVolume, labelmap, worldPosition, options);
    return labelmap;
}
async function runOneClickGrowCut(referencedVolumeId, worldPosition, viewport, options) {
    const referencedVolume = cache.getVolume(referencedVolumeId);
    const positiveRegionData = _getPositiveRegionData(referencedVolume, worldPosition, options);
    const subVolume = _createSubVolume(referencedVolume, positiveRegionData, options);
    const labelmap = await _createAndCacheSegmentation(subVolume, positiveRegionData, worldPosition, options);
    await run(subVolume.volumeId, labelmap.volumeId);
    return labelmap;
}
export { runOneClickGrowCut as default, runOneClickGrowCut };
