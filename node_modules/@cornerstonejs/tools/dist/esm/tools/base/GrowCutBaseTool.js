import { getEnabledElement, utilities as csUtils, cache, getRenderingEngine, StackViewport, } from '@cornerstonejs/core';
import { BaseTool } from '../base';
import { SegmentationRepresentations } from '../../enums';
import { segmentIndex as segmentIndexController, state as segmentationState, activeSegmentation, } from '../../stateManagement/segmentation';
import { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';
import { getSVGStyleForSegment } from '../../utilities/segmentation/getSVGStyleForSegment';
import IslandRemoval from '../../utilities/segmentation/islandRemoval';
const { transformWorldToIndex, transformIndexToWorld } = csUtils;
class GrowCutBaseTool extends BaseTool {
    static { this.lastGrowCutCommand = null; }
    constructor(toolProps, defaultToolProps) {
        const baseToolProps = csUtils.deepMerge({
            configuration: {
                positiveSeedVariance: 0.1,
                negativeSeedVariance: 0.9,
                shrinkExpandIncrement: 0.05,
                islandRemoval: {
                    enabled: false,
                },
            },
        }, defaultToolProps);
        super(toolProps, baseToolProps);
    }
    async preMouseDownCallback(evt) {
        const eventData = evt.detail;
        const { element, currentPoints } = eventData;
        const { world: worldPoint } = currentPoints;
        const enabledElement = getEnabledElement(element);
        const { viewport, renderingEngine } = enabledElement;
        const { viewUp } = viewport.getCamera();
        const { segmentationId, segmentIndex, labelmapVolumeId, referencedVolumeId, } = await this.getLabelmapSegmentationData(viewport);
        if (!this._isOrthogonalView(viewport, referencedVolumeId)) {
            throw new Error('Oblique view is not supported yet');
        }
        this.growCutData = {
            metadata: {
                ...viewport.getViewReference({ points: [worldPoint] }),
                viewUp,
            },
            segmentation: {
                segmentationId,
                segmentIndex,
                labelmapVolumeId,
                referencedVolumeId,
            },
            viewportId: viewport.id,
            renderingEngineId: renderingEngine.id,
        };
        evt.preventDefault();
        return true;
    }
    shrink() {
        this._runLastCommand({
            shrinkExpandAmount: -this.configuration.shrinkExpandIncrement,
        });
    }
    expand() {
        this._runLastCommand({
            shrinkExpandAmount: this.configuration.shrinkExpandIncrement,
        });
    }
    refresh() {
        this._runLastCommand();
    }
    async getGrowCutLabelmap(_growCutData) {
        throw new Error('Not implemented');
    }
    async runGrowCut() {
        const { growCutData, configuration: config } = this;
        const { segmentation: { segmentationId, segmentIndex, labelmapVolumeId }, } = growCutData;
        const hasSeedVarianceData = config.positiveSeedVariance !== undefined &&
            config.negativeSeedVariance !== undefined;
        const labelmap = cache.getVolume(labelmapVolumeId);
        let shrinkExpandValue = 0;
        const growCutCommand = async ({ shrinkExpandAmount = 0 } = {}) => {
            const { positiveSeedVariance, negativeSeedVariance } = config;
            let newPositiveSeedVariance = undefined;
            let newNegativeSeedVariance = undefined;
            shrinkExpandValue += shrinkExpandAmount;
            if (hasSeedVarianceData) {
                newPositiveSeedVariance = positiveSeedVariance + shrinkExpandValue;
                newNegativeSeedVariance = negativeSeedVariance + shrinkExpandValue;
            }
            const updatedGrowCutData = Object.assign({}, growCutData, {
                options: {
                    positiveSeedValue: segmentIndex,
                    negativeSeedValue: 255,
                    positiveSeedVariance: newPositiveSeedVariance,
                    negativeSeedVariance: newNegativeSeedVariance,
                },
            });
            const growcutLabelmap = await this.getGrowCutLabelmap(updatedGrowCutData);
            this.applyGrowCutLabelmap(segmentationId, segmentIndex, labelmap, growcutLabelmap);
            this._removeIslands(growCutData);
        };
        await growCutCommand();
        if (hasSeedVarianceData) {
            GrowCutBaseTool.lastGrowCutCommand = growCutCommand;
        }
        this.growCutData = null;
    }
    applyGrowCutLabelmap(segmentationId, segmentIndex, targetLabelmap, sourceLabelmap) {
        const srcLabelmapData = sourceLabelmap.voxelManager.getCompleteScalarDataArray();
        const tgtVoxelManager = targetLabelmap.voxelManager;
        const [srcColumns, srcRows, srcNumSlices] = sourceLabelmap.dimensions;
        const [tgtColumns, tgtRows] = targetLabelmap.dimensions;
        const srcPixelsPerSlice = srcColumns * srcRows;
        const tgtPixelsPerSlice = tgtColumns * tgtRows;
        for (let srcSlice = 0; srcSlice < srcNumSlices; srcSlice++) {
            for (let srcRow = 0; srcRow < srcRows; srcRow++) {
                const srcRowIJK = [0, srcRow, srcSlice];
                const rowVoxelWorld = transformIndexToWorld(sourceLabelmap.imageData, srcRowIJK);
                const tgtRowIJK = transformWorldToIndex(targetLabelmap.imageData, rowVoxelWorld);
                const [tgtColumn, tgtRow, tgtSlice] = tgtRowIJK;
                const srcOffset = srcRow * srcColumns + srcSlice * srcPixelsPerSlice;
                const tgtOffset = tgtColumn + tgtRow * tgtColumns + tgtSlice * tgtPixelsPerSlice;
                for (let column = 0; column < srcColumns; column++) {
                    const labelmapValue = srcLabelmapData[srcOffset + column] === segmentIndex
                        ? segmentIndex
                        : 0;
                    tgtVoxelManager.setAtIndex(tgtOffset + column, labelmapValue);
                }
            }
        }
        triggerSegmentationDataModified(segmentationId);
    }
    _runLastCommand({ shrinkExpandAmount = 0 } = {}) {
        const cmd = GrowCutBaseTool.lastGrowCutCommand;
        if (cmd) {
            cmd({ shrinkExpandAmount });
        }
    }
    async getLabelmapSegmentationData(viewport) {
        const activeSeg = activeSegmentation.getActiveSegmentation(viewport.id);
        if (!activeSeg) {
            throw new Error('No active segmentation found');
        }
        const { segmentationId } = activeSeg;
        const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);
        const { representationData } = segmentationState.getSegmentation(segmentationId);
        const labelmapData = representationData[SegmentationRepresentations.Labelmap];
        const { volumeId: labelmapVolumeId, referencedVolumeId } = labelmapData;
        if (!labelmapVolumeId) {
            throw new Error('Labelmap volume id not found - not implemented');
        }
        return {
            segmentationId,
            segmentIndex,
            labelmapVolumeId,
            referencedVolumeId,
        };
    }
    _isOrthogonalView(viewport, referencedVolumeId) {
        const volume = cache.getVolume(referencedVolumeId);
        const volumeImageData = volume.imageData;
        const camera = viewport.getCamera();
        const { ijkVecColDir, ijkVecSliceDir } = csUtils.getVolumeDirectionVectors(volumeImageData, camera);
        return [ijkVecColDir, ijkVecSliceDir].every((vec) => csUtils.isEqual(Math.abs(vec[0]), 1) ||
            csUtils.isEqual(Math.abs(vec[1]), 1) ||
            csUtils.isEqual(Math.abs(vec[2]), 1));
    }
    getRemoveIslandData(_growCutData) {
        return;
    }
    _removeIslands(growCutData) {
        const { islandRemoval: config } = this.configuration;
        if (!config.enabled) {
            return;
        }
        const { segmentation: { segmentIndex, labelmapVolumeId }, renderingEngineId, viewportId, } = growCutData;
        const labelmap = cache.getVolume(labelmapVolumeId);
        const removeIslandData = this.getRemoveIslandData(growCutData);
        if (!removeIslandData) {
            return;
        }
        const [width, height] = labelmap.dimensions;
        const numPixelsPerSlice = width * height;
        const { worldIslandPoints = [], islandPointIndexes = [] } = removeIslandData;
        let ijkIslandPoints = [...(removeIslandData?.ijkIslandPoints ?? [])];
        const renderingEngine = getRenderingEngine(renderingEngineId);
        const viewport = renderingEngine.getViewport(viewportId);
        const { voxelManager } = labelmap;
        const islandRemoval = new IslandRemoval();
        ijkIslandPoints = ijkIslandPoints.concat(worldIslandPoints.map((worldPoint) => transformWorldToIndex(labelmap.imageData, worldPoint)));
        ijkIslandPoints = ijkIslandPoints.concat(islandPointIndexes.map((pointIndex) => {
            const x = pointIndex % width;
            const y = Math.floor(pointIndex / width) % height;
            const z = Math.floor(pointIndex / numPixelsPerSlice);
            return [x, y, z];
        }));
        islandRemoval.initialize(viewport, voxelManager, {
            points: ijkIslandPoints,
            previewSegmentIndex: segmentIndex,
            segmentIndex,
        });
        islandRemoval.floodFillSegmentIsland();
        islandRemoval.removeExternalIslands();
        islandRemoval.removeInternalIslands();
    }
    getSegmentStyle({ segmentationId, viewportId, segmentIndex }) {
        return getSVGStyleForSegment({
            segmentationId,
            segmentIndex,
            viewportId,
        });
    }
}
GrowCutBaseTool.toolName = 'GrowCutBaseTool';
export default GrowCutBaseTool;
