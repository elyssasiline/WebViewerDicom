import { expose } from 'comlink';
import { utilities } from '@cornerstonejs/core';
import VolumetricCalculator from '../utilities/segmentation/VolumetricCalculator';
const { VoxelManager } = utilities;
const computeWorker = {
    calculateSegmentsStatisticsVolume: (args) => {
        const { segmentationInfo, imageInfo, indices } = args;
        const { scalarData: segmentationScalarData, dimensions: segmentationDimensions, spacing: segmentationSpacing, } = segmentationInfo;
        const { scalarData: imageScalarData, dimensions: imageDimensions } = imageInfo;
        if (segmentationDimensions[0] !== imageDimensions[0] ||
            segmentationDimensions[1] !== imageDimensions[1] ||
            segmentationDimensions[2] !== imageDimensions[2]) {
            throw new Error('Dimensions do not match to calculate statistics, different dimensions not supported yet');
        }
        const segVoxelManager = VoxelManager.createScalarVolumeVoxelManager({
            dimensions: segmentationDimensions,
            scalarData: segmentationScalarData,
        });
        const imageVoxelManager = VoxelManager.createScalarVolumeVoxelManager({
            dimensions: imageDimensions,
            scalarData: imageScalarData,
        });
        segVoxelManager.forEach(({ value, pointIJK, index }) => {
            if (indices.indexOf(value) === -1) {
                return;
            }
            const imageValue = imageVoxelManager.getAtIndex(index);
            VolumetricCalculator.statsCallback({
                value: imageValue,
                pointIJK,
            });
        }, {
            boundsIJK: imageVoxelManager.getDefaultBounds(),
        });
        const stats = VolumetricCalculator.getStatistics({
            spacing: segmentationSpacing,
            unit: 'mm',
        });
        return stats;
    },
    calculateSegmentsStatisticsStack: (args) => {
        const { segmentationInfo, imageInfo, indices } = args;
        for (let i = 0; i < segmentationInfo.length; i++) {
            const segInfo = segmentationInfo[i];
            const imgInfo = imageInfo[i];
            const segDimensions = [
                segInfo.dimensions[0],
                segInfo.dimensions[1],
                1,
            ];
            const segVoxelManager = VoxelManager.createScalarVolumeVoxelManager({
                dimensions: segDimensions,
                scalarData: segInfo.scalarData,
            });
            const imageVoxelManager = VoxelManager.createScalarVolumeVoxelManager({
                dimensions: segDimensions,
                scalarData: imgInfo.scalarData,
            });
            segVoxelManager.forEach(({ value, pointIJK, index }) => {
                if (indices.indexOf(value) === -1) {
                    return;
                }
                const imageValue = imageVoxelManager.getAtIndex(index);
                VolumetricCalculator.statsCallback({
                    value: imageValue,
                });
            }, {
                boundsIJK: imageVoxelManager.getDefaultBounds(),
            });
        }
        const spacing = segmentationInfo[0].spacing;
        const stats = VolumetricCalculator.getStatistics({
            spacing,
        });
        return stats;
    },
};
expose(computeWorker);
